# 호이스팅이란?

- hoist : (흔히 밧줄이나 장비를 이용하여) **들어[끌어]올리다**

→ 무언가 끌어올리는 것이구나!

## **메모리**

메모리는 데이터를 저장할 수 있는 메모리 셀(8bit == 1byte)의 집합체

각 셀에는 고유의 메모리 주소가 있다, 메모리 주소는 0부터 정수로 표현된다.

```jsx
10+20
```

표현식의 해석 결과를 메모리에 저장, 그럼 접근은 어떻게 하지?

1. 직접 메모리 주소를 이용해 접근하기 → 오류를 발생시킬 확률이 매우 높아짐, 메모리 주소는 매번 바뀐다.
2. 변수를 이용한다!

## **변수**

하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름, (= 값의 위치를 가리키는 상징적인 이름이다.)

```jsx
var sum = 10+20
```

표현식을 통해 새로운 값 생성되고, 그 값은 메모리에 저장된다.

값이 담긴 메모리 공간에 상징적인 이름을 붙인 sum을 이용해 접근할 수 있다.

⇒ 용어 정리!

- **변수** : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름

- **변수 값** : 변수에 저장된 값

- **할당** : 변수에 값을 저장하는 것

- **참조** : 변수에 저장된 값을 읽어 들이는 것

- **변수 선언**
  
  변수를 사용하려면 반드시 선언이 필요하다
  
  변수 선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지는 누구도 사용하지 못하도록 보호되기 때문!
  
  선언할 때 필요한 키워드 : `var` , `let` , `const`
  
  ---
  
  자바스크립트 엔진은 변수 선언을 2단계에 걸쳐 수행한다
  
  1. 선언 단계
  2. 초기화 단계

```jsx
var sum = 10+20
```

변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다.

선언 단계에서 변수 이름을 **실행 컨텍스트**에 저장, 암묵적으로 **undefined를 할당**한다.

초기화를 하지 않으면? 쓰레기값이 남아있음.

### 실행 컨텍스트가 머야!

나두 몰라!! ㅜ

## 변수 호이스팅

변수 선언은 소스코드를 한 줄씩 실행하는 런타임이 아니라 그 이전 단계에 먼저 실행된다.

자바스크립트 엔진은 소스코드를 실행하기 전, 소스코드의 평가과정을 거치며 소스코드를 실행하기 위해 준비한다.

따라서 자바스크립트 엔진은, 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다.

→ 변수 선언이 어디에 있든 변수를 참조할 수 있음

*변수 선언문이 코드의 선두로 **끌어올려진 것처럼** 동작하는 자바스크립트 고유의 특징이 바로 변수 호이스팅!*

(꼭 변수 뿐 아니더라도 모든 식별자는 호이스팅된다)

**그럼 10+20의 결과값인 30은 언제 할당되는거지? → 아래 *값의 할당*에서!**

### 변수 호이스팅은 키워드에 따라 달라진다규!

- **var 키워드 → 변수 호이스팅 발생**

- let, const, class 키워드
  
  → 호이스팅 발생X, 선언 단계와 초기화 단계가 분리되어 진행된다.
  
  런타임 이전 자바스크립트 엔진에 의해 선언단계는 실행되지만, 초기화 단계는 런타임에 실행된다.
  
  따라서 초기화 단계 이전에 함수에 접근하면 참조 에러가 뜬다
  
  정확히는 호이스팅이 발생하지 않는 것이 아니라, 호이스팅이 발생하지 않는 것처럼 동작함
  
  ```jsx
  let foo = 1;
  {
      console.log(foo);   // RefferenceError, 만약 호이스팅이 발생하지 않는다면 1을 출력했을 것이다
      let foo = 2;
  }
  ```

## 값의 할당

할당 연산자는 `=` 이다!

변수 선언과 값의 할당은 실행 시점이 다르다!

변수 선언은 런타임 이전에 실행, undefined로 초기화

값의 할당은 런타임에 실행된다.

## 함수 호이스팅

함수를 어떻게 정의했는지에 따라 호이스팅이 일어나지 않기도 한다.

함수 **선언문** → 함수 호이스팅 **발생**

```jsx
// 함수 선언문
function hello(){
    print('hello');
}
```

함수 **표현식** → 함수 호이스팅 **발생X**

```jsx
// 함수 표현식
var hello = function(){
    print('hello');
};
```

그럼 선언문과 표현식의 **차이**는 무엇인가!?

### 표현식

값으로 평가(=값을 리턴한다)될 수 있는 문, 값으로 평가될 수 있는 문은 모두 표현식이다!

```jsx
var score = 100;
var score = 50+50;
```

### 문

문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다, 컴퓨터에 내리는 명령으로도 볼 수 있음

선언문, 할당문, 반복문 등

```jsx
//반복문
for(var i=0; i<5; i++){
    console.log(i);
}
```

### 표현식인 문과 표현식이 아닌 문

표현식인 문은 값으로 평가될 수 있는 문(결과를 리턴함)

표현식이 아닌 문은 표현식으로 평가될 수 없는 문

---

다시 함수 표현식과 함수 선언문으로 돌아오면!

- **함수 표현식**
  
  변수가 선언되고 초기화(undefined)
  
  런타임 과정에서 함수 표현식 실행, 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다

- **함수 선언문**
  
  런타임 이전에 함수 객체를 먼저 생성한다
  
  자바스크립트 엔진이 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성, 생성된 함수를 할당한다.
  
  → 런타임 이전에 이미 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태
  
  ⇒ 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작한다!!(==함수 호이스팅)

## 클래스 호이스팅

클래스는 함수로 평가된다

클래스 선언문으로 정의한 클래스는 함수 선언문처럼 평가된다
